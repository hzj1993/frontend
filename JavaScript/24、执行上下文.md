执行上下文时JavaScript中很重要的一块知识，也是JavaScript的基础之一，原本我以为我已经够理解执行上下文，但是某天无意中看到一道题，
我发现我并未非常理解执行上下文。

题目如下：
```javascript
function sidEffecting(ary) {
  ary[0] = ary[2];
}
function bar(a, b, c) {
  c = 10;
  sidEffecting(arguments);
  return a + b + c;
}
bar(1, 1, 1);
// 输出：21
```

输出21是因为`arguments`对象与函数参数进行绑定，对`arguments`改动会影响到参数的值。

可是我答错了，我以为会输出12。这反映我并未足够理解`arguments`，由于`arguments`对象是在创建执行上下文中创建的，
也反映了我对该部分知识还存在盲区，于是我决定重新再理一遍执行上下文的创建过程。

我之前对于函数的执行上下文的创建过程的认识是这样的：

```
1、函数的执行上下文创建，并压入调用栈
2、复制函数的[[scope]]内部属性创建作用域链
3、以arguments对象创建变量对象VO，并把函数内声明的变量以及函数提升并添加到变量对象内，声明的变量初始化为undefined，函数为声明的函数
4、变量对象VO激活为活动对象AO，并把AO添加到作用域链前端
5、确定this的指向
6、执行上下文创建完成
```

不难看出，之前对于执行上下文的认识还是比较浅薄的，部分概念还是没深入，例如 `augrments`怎么创建、`this`怎么确定、`[[scope]]`内部属性的值怎么来的等等。

### arguments 对象的创建

重新撸了一下规范，先来说说`arguments`对象的创建：

提取规范中关键逻辑后，简化版：
```
1. 创建一个变量 len 值为 argumentsList 的长度，其中argumentsList是传入函数的实际参数
2. 创建一个新的对象 obj，并初始化这个对象的[[GetOwnProperty]]，[[Get]]，[[Set]]，[[DefineOwnProperty]]，[[Delete]]，
[[Prototype]]设置为 Object.prototype
3. 设置 index = 0，index < len，开始循环
4. 调用 obj 的 [[DefineOwnProperty]] 方法，将argumentsList的值设置为 obj 对象的值，相当于 obj[index++] = argumentsList[index++] 
5. 循环结束
6. 然后设置 obj.length = len，=> { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }
7. 设置形参列表为实参列表对应的值，如果实参列表 argumentsList 的长度小于形参长度，形参多余的元素不做处理
8. 如果此时不是处于严格模式，将此前创建的 obj 对象的各个字段与形参绑定起来
9. 如果不是严格模式，设置 obj.callee 为当前函数
10. 如果是严格模式，设置 obj.callee 和 obj.caller 的[[Get]]、[[Set]]为抛错函数
11. 返回 obj
```

总结：

arguments 创建会以实参进行初始化，并与形参绑定关系，同时也会创建 callee 属性，指向函数自身

### this 绑定


来源资料：

[w3中文文档 ES5](https://www.w3.org/html/ig/zh/wiki/ES5)
[ecma-262 2019规范](https://tc39.es/ecma262/#sec-execution-contexts)
[汤姆大叔 深入JS系列](https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)